" Vim filetype plugin file
" Language:         Haskell
" Maintainer:       haskell-cafe@haskell.org
" Author:           Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2006-11-21

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another ftplugin for this buffer
let b:did_ftplugin = 1

let s:save_cpo = &cpo
let b:saved_cpo = &cpoptions
setlocal cpoptions-=C

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal formatoptions-=t formatoptions+=croql

" Set 'comments' to allow both {- -} and -- style comments
setlocal comments=s1:{-,mb:-,ex:-},:-- 

" Set 'commentstring' to insert -- style comments when adding 
" fold markers by hand
setlocal commentstring=--\ %s

" Enable gf on import lines. Convert . in the package name to / and 
" append .hs, then search the path.
setlocal includeexpr=substitute(v:fname,'\\.','/','g')
setlocal suffixesadd=.hs
if exists("g:ftplugin_haskell_source_path")
    let &l:path=g:ftplugin_haskell_source_path . ',' . &l:path
endif

" Ignore generated .hi
setlocal suffixes+=.hi

" Add <LocalLeader>t as command to add type declarations, if ghci exists
call system ("ghci --version")
if !v:shell_error
    if !exists("*s:HSActuallyGetType")
        if v:version < 700 
            function s:HSActuallyGetType(firstword)
                if has("unix")
                    return (system('echo ":t '. a:firstword . '" | ghci -v0 -cpp -w ' . expand('%')))
                else
                    return ("No pipes possible?")
                endif
            endfunction
        else
            function s:HSActuallyGetType(firstword)
                return (system('ghci -v0 -cpp -w ' . expand('%'), ':t ' . a:firstword))
            endfunction
        endif
    endif

    if !exists("*HSGetType")
        function HSGetType()
            let l:line = getline(line('.'))
            let l:firstword = matchstr(l:line, '[^[:space:]]\+')
            if l:line =~ (l:firstword . ' ::')
                return
            endif
            let l:type = s:HSActuallyGetType(l:firstword)
            let l:type = substitute(l:type, "[[:space:]]$", "", "")
            let l:previousline = getline(line('.')-1)
            if l:type =~ (l:firstword . ' ::')
                if l:previousline =~ (l:firstword . ' ::')
                    call setline(line('.')-1, l:type)
                elseif l:previousline =~ ('-- type for ' . l:firstword . ' could not be autogenerated')
                    call setline(line('.')-1, l:type)
                else
                    call append(line('.')-1, l:type)
                endif
            elseif l:previousline !~ ('-- type for ' . l:firstword . ' could not be autogenerated')
                call append(line('.')-1, '-- type for ' . l:firstword . ' could not be autogenerated')
            endif
        endfunction
    endif
    nmap <buffer><silent> <LocalLeader>t :call HSGetType()<CR>
endif

" Folding support
if has("folding")
    if exists('g:haskell_folding')
        setlocal foldmethod=HSFoldLevel(v:lnum)
    "    setlocal foldtext=HSFoldText(v:lnum)
        setlocal foldexpr=expr
    endif

    if !exists("*HSFoldLevel")
        function HSFoldLevel(lnum)
            let l:line = getline(a:lnum)
            let l:indent = indent(a:lnum)
            let l:commentid = synIDtrans(hlID("hsComment"))
            let l:lineid = synIDtrans(synID(a:lnum,indent(a:lnum)+4,0))

            if l:lineid == l:commentid
                return "="
            endif

            " Support markers in comments
            let l:markers = split(&foldmarker,",")
            if l:line =~ "-- .*".l:markers[0] 
                let l:count = matchstr(l:line , (l:markers[0]).'\zs\d*')
                if l:count == ""
                    return "a1"
                else
                    return ">".l:count
                endif
            endif
            if l:line =~ "-- .*".l:markers[1]
                let l:count = matchstr(l:line, (l:markers[1]).'\zs\d*')
                if l:count == ""
                    return "s1"
                else
                    return "<".l:count
                endif
            endif

            " If an empty line is followed by a line with indent 0, this
            " line ends the current fold.
            "
            if l:line =~ '^\s*$'
                let l:nextline = getline(a:lnum+1)
                let l:nextlineid = synIDtrans(synID(a:lnum + 1,indent(a:lnum+1)+4,0))
                if (l:nextline !~ '^\s*$') && indent(a:lnum+1) == 0 && l:nextlineid != l:commentid
                return ">0"
                else
                    return "="
                endif
            elseif getline(a:lnum-1) =~ '^\s*$'
                if indent(a:lnum) == 0
                    return ">1"
                else
                    return "="
                endif
            endif

            return "="
        endfunction
    endif
endif

" Undo the stuff we changed
let b:undo_ftplugin = "setlocal comments< commentstring< formatoptions<" .
            \         " omnifunc< cpoptions< includeexpr< suffixesadd<" .
            \         " | let &cpo = b:saved_cpo | !unlet b:saved_cpo "

let &cpo = s:save_cpo
" Disable backslashing of brackets, so matching works well even in the
" presence of lambda abstractions for tuples
setlocal cpoptions+=M

" screen.vim stuff
if !exists("g:screen_sessionname") || !exists("g:screen_windowname")
	let g:screen_sessionname = "ghci"
	let g:screen_windowname = "0"
end

